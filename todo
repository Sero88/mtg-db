Doing:
Continue working on incorporating the collection data into the add search . 

Will also need to fix set issue. Not show sets or allow multiple sets to be chosen, or similar sets are checked, when user selects kaldheim, all the kaldheim sets available are checked.

*** We will show results and query both the collection and the API
**** Since the card component is going to be used on both the "add" and "search" functionalities the card state will be in search Results along with the handler to add/remove cards.
**** [cont] we will pass getCollection data from search to card component

* Add the set selection functionality (any set - or specify the set)
*** Read about hooks for React - we need to get the sets after the components are mounted
*** Add an allowed set_type list for sets to avoid showing irrelevant sets. Then continue with the listener for set change.
*** Finish testing sets. Then move on to adding the add functionality.

*** continue combining collection with results data - working on getting collection without creating an infinite loop
*** does the collection have a set array and there keep quantity. --> No, it is better to have an object for each card, since one set can have multiple types of the same card
=========================
Tasks

About: 
The site will basically be a user API to access the database. Without logging in, the user won't have access. 

Calling scryfall API
This is the structure of how the db will be saved. Pretty much just data 
that pertains to our collection. 

Treat cards that are two-cards-in-one separate. If the card_face object exists, save the other face in a separate table. 
These type of cards won't count against total. Will have their own entries, but when doing search will join these tables with $lookup

ID (automatically by MongoDB)
(don't need scryfall id because we will hold many different types/sets)



CARD OBJECT: 
_id: object
scryfallId: string
OracleId: string (same across reprinted card editions)
Card Name: string
color_identity: string[],
sets: string[] (use unique print or prints_search_uri), 
Quantity: number,
card_type: "normal|dual" (my own field based on scryfall face count)
legalities: {}
loyalty: number|null
name: string
type_line: string
artist: string
rarity: string
sets: object[{khm: 5}] does the collection have a set array and there keep quantity
number: string 


Each card is going to have a face, regardless if it only has one.
Face properties:
mana_cost: string | null ( we need to write a regular expression to convert mana_cost value if dual cards)
keywords: string[],
name: string (each face has a name apart from full card name)
power: string | null
toughness: string | null 
oracle_text: string[],
flavor_text: string|null
image_uri = using image_uris field get one url (normal)















===> Correction with these. Since we plan on doing a comprehensive search, we need 
all the fields that Scryfall provides. Example: I want to search all green colored cards. 
With the fields above I wouldn't be able to do, however if I save all the scryfall data, I can easily query
data like this. 



Develop search functionality
* Plan it, view scryfall to get ideas. 




===done

We can now add to the db. Finetune the response you get from the update query. Fix headers sent error. Finish adding cards functionality then proceed to combine when making a search.


Continue working on add functionality. I have passed the card object from the PUT request, now is time to pass it to the db. Upsert and add one to the quantity.
Add functionality


I just added the listener functioanlity for add card collection menu. Next step is to add a card to the database.
* Solve issue about game:paper, to only show paper sets and also issue about collection number and set_type. Showing collection number with promo next to it. P for prmo, S for prerelease

Follows what we're adding to the db in our collection. The same fields.
* Plan it - when search have a + sign to add to collection or remove
** Add card will depend on the name of the card in order to search the API
*  Make sure you distinguish between promos

**** show prints when user searches for specific card or if the general results show only one of that card (general results only show one, but can have many prints)
**** troubleshoot issue with missing results - fine tune what shows when. Right now results are dissapearing b/c it resets to false, do we need to separat
**** Finish suggestion functionality - pass the name to the input field
****delete the suggestions after user chooses one
*** continue working on getting search results working with typescript - plan it if necessary take some time to get the Typescript down

*** We will do an autocomplete functionality after a certain pause in typing

*** continue writing down the fields that we want to store in the database and thus create a type: card
**** quickly review fields and then continue with next task of querying the api for a card and showing results
**** organize todo. Then architect scryfall api call better. Do we need a repository structure - probably not. But we do need to structure it better, maybe move Scryfall functionality to its own class
**** Continue figuring out when to show the suggestion box. May have to move to search by name rather than suggestion box

Develop the header 
*Setup icons and add them to the navigation links
Develop the home page structure


Authentication
* Set up authentication on App.js - if user is not logged in, take user to the logging page
** Continue figuring out how to make sure user is authenticated. Remember - if using front-end then you 
need to use client-side rendering - otherwise you can use back-end for everything. 

==> So in order to make sure the user is signed, we will use a <secureLayout> component that first check whether
the user is logged in to know what type of data to show. 
Q: Will this be pre-rendered or will we need to do server side rendering or even client side - fetch as needed. 
Answer:  Client side, because it will use UseEffect by react to update when session changes. So it depends on client side code!, 
but the regular static page is the login page message. 


Start creating todo outline and planning

* get familiar with authentication
* get familiar with authorization - how to know when user is logged in.

